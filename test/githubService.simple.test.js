import { test, describe } from 'node:test';
import assert from 'node:assert';

describe('GitHub Service - Core Logic Tests', () => {
    
    test('should validate PR body generation logic', () => {
        // Test the logic for generating PR body content
        const issueNumber = 42;
        const issueTitle = 'Fix critical bug in authentication system';
        const commitMessage = 'fix(auth): resolve login validation issue\n\nFixed null pointer exception when validating user credentials.';
        const claudeResult = {
            success: true,
            executionTime: 15000,
            finalResult: {
                num_turns: 5,
                cost_usd: 0.15
            },
            sessionId: 'session-abc-123',
            summary: 'Fixed the authentication bug by adding proper null checks and error handling'
        };

        // Manually create PR body to test the logic (extracted from the actual function)
        const timestamp = new Date().toISOString();
        const executionTime = Math.round((claudeResult?.executionTime || 0) / 1000);
        
        let body = `## ðŸ¤– AI-Generated Solution\n\n`;
        body += `Resolves #${issueNumber}.\n\n`;
        body += `This Pull Request was automatically generated by Claude Code to address the issue: **${issueTitle}**\n\n`;
        
        body += `### ðŸ“‹ Execution Summary\n\n`;
        body += `- **Status**: ${claudeResult.success ? 'âœ… Success' : 'âŒ Failed'}\n`;
        body += `- **Execution Time**: ${executionTime}s\n`;
        body += `- **Generated**: ${timestamp}\n`;
        
        if (claudeResult?.finalResult) {
            const result = claudeResult.finalResult;
            body += `- **Claude Turns**: ${result.num_turns || 'unknown'}\n`;
            body += `- **Cost**: $${result.cost_usd || 'unknown'}\n`;
            body += `- **Session ID**: \`${claudeResult.sessionId || 'unknown'}\`\n`;
        }

        // Verify the body contains expected elements
        assert(body.includes('Resolves #42'));
        assert(body.includes('Fix critical bug in authentication system'));
        assert(body.includes('âœ… Success'));
        assert(body.includes('15s'));
        assert(body.includes('Claude Turns**: 5'));
        assert(body.includes('Cost**: $0.15'));
        assert(body.includes('session-abc-123'));
        assert(body.length > 100, 'PR body should be substantial');
    });

    test('should validate Claude logs comment generation logic', () => {
        const claudeResult = {
            success: true,
            sessionId: 'test-session-123',
            executionTime: 5000,
            finalResult: {
                num_turns: 3,
                cost_usd: 0.08,
                subtype: null
            },
            conversationLog: [
                { type: 'user', message: { content: 'Fix this authentication bug' } },
                { type: 'assistant', message: { content: [{ text: 'I will analyze the code and fix the authentication issue.' }] } },
                { type: 'user', message: { content: 'Please also add tests' } }
            ],
            rawOutput: 'Claude executed successfully and made the following changes:\n- Fixed null pointer exception\n- Added proper error handling\n- Created unit tests'
        };
        const issueNumber = 42;

        // Generate comment content (extracted logic from actual function)
        let comment = `## ðŸ” Claude Code Execution Logs\n\n`;
        comment += `**Issue**: #${issueNumber}\n`;
        comment += `**Session ID**: \`${claudeResult?.sessionId || 'unknown'}\`\n`;
        comment += `**Timestamp**: ${new Date().toISOString()}\n\n`;

        // Add execution details
        if (claudeResult?.finalResult) {
            const result = claudeResult.finalResult;
            comment += `### ðŸ“Š Execution Statistics\n\n`;
            comment += `- **Success**: ${claudeResult.success ? 'Yes' : 'No'}\n`;
            comment += `- **Total Turns**: ${result.num_turns || 'unknown'}\n`;
            comment += `- **Execution Time**: ${Math.round((claudeResult.executionTime || 0) / 1000)}s\n`;
            comment += `- **Cost**: $${result.cost_usd || 'unknown'}\n\n`;
        }

        // Add conversation summary
        if (claudeResult?.conversationLog && claudeResult.conversationLog.length > 0) {
            comment += `### ðŸ’¬ Conversation Summary\n\n`;
            comment += `Total messages exchanged: ${claudeResult.conversationLog.length}\n\n`;
        }

        // Verify the comment contains expected elements
        assert(comment.includes('Claude Code Execution Logs'));
        assert(comment.includes('#42'));
        assert(comment.includes('test-session-123'));
        assert(comment.includes('Success**: Yes'));
        assert(comment.includes('Total Turns**: 3'));
        assert(comment.includes('5s'));
        assert(comment.includes('$0.08'));
        assert(comment.includes('Total messages exchanged: 3'));
        assert(comment.length > 200, 'Comment should be substantial');
    });

    test('should validate label update logic', () => {
        const currentLabels = ['bug', 'AI-processing', 'priority-high'];
        const labelsToRemove = ['AI-processing'];
        const labelsToAdd = ['AI-done'];

        // Calculate new labels set (extracted logic from actual function)
        const updatedLabels = [
            ...currentLabels.filter(label => !labelsToRemove.includes(label)),
            ...labelsToAdd.filter(label => !currentLabels.includes(label))
        ];

        assert.deepStrictEqual(updatedLabels, ['bug', 'priority-high', 'AI-done']);
    });

    test('should handle duplicate labels correctly', () => {
        const currentLabels = ['bug', 'AI-done']; // Already has the label we want to add
        const labelsToRemove = ['AI-processing']; // Label not present
        const labelsToAdd = ['AI-done']; // Label already present

        const updatedLabels = [
            ...currentLabels.filter(label => !labelsToRemove.includes(label)),
            ...labelsToAdd.filter(label => !currentLabels.includes(label))
        ];

        assert.deepStrictEqual(updatedLabels, ['bug', 'AI-done']);
    });

    test('should validate commit message generation logic', () => {
        const issueNumber = 42;
        const issueTitle = 'Very Long Issue Title That Should Be Truncated to Fit in Commit Message Properly';
        
        // Generate structured commit message (extracted logic from repoManager)
        const shortTitle = issueTitle ? issueTitle.substring(0, 50).replace(/\s+/g, ' ').trim() : 'issue fix';
        const commitMessage = `fix(ai): Resolve issue #${issueNumber} - ${shortTitle}

Implemented by Claude Code. Full conversation log in PR comment.`;

        assert(commitMessage.includes('fix(ai): Resolve issue #42'));
        assert(commitMessage.includes('Very Long Issue Title That Should Be Truncated'));
        assert(commitMessage.includes('Implemented by Claude Code'));
        assert(commitMessage.length < 200, 'Commit message should be reasonably sized');
        
        // Verify the title was truncated properly
        const extractedTitle = commitMessage.match(/- (.+)/)[1].split('\n')[0];
        assert(extractedTitle.length <= 50, 'Title should be truncated to 50 characters');
    });

    test('should validate retention info structure', () => {
        const retentionHours = 24;
        const retentionInfo = {
            timestamp: new Date().toISOString(),
            issueProcessed: true,
            success: false,
            retentionHours,
            scheduledCleanup: new Date(Date.now() + retentionHours * 60 * 60 * 1000).toISOString()
        };

        assert(typeof retentionInfo.timestamp === 'string');
        assert(retentionInfo.issueProcessed === true);
        assert(retentionInfo.success === false);
        assert(retentionInfo.retentionHours === 24);
        assert(typeof retentionInfo.scheduledCleanup === 'string');
        
        // Verify the scheduled cleanup is approximately 24 hours in the future
        const scheduledTime = new Date(retentionInfo.scheduledCleanup);
        const expectedTime = new Date(Date.now() + 24 * 60 * 60 * 1000);
        const timeDiff = Math.abs(scheduledTime.getTime() - expectedTime.getTime());
        assert(timeDiff < 5000, 'Scheduled cleanup time should be approximately 24 hours from now');
    });

    test('should validate GitHub comment length limits', () => {
        const MAX_COMMENT_LENGTH = 65000;
        
        // Create a very long comment
        let longComment = 'A'.repeat(70000);
        
        // Apply truncation logic (extracted from actual function)
        if (longComment.length > MAX_COMMENT_LENGTH) {
            const truncatePoint = MAX_COMMENT_LENGTH - 200;
            longComment = longComment.substring(0, truncatePoint);
            longComment += '\n\n[Comment truncated due to GitHub length limits]\n';
            longComment += `\nFull logs are available in the system logs.`;
        }

        assert(longComment.length <= MAX_COMMENT_LENGTH, 'Comment should be within GitHub limits');
        assert(longComment.includes('Comment truncated due to GitHub length limits'));
    });
});

describe('GitHub Service - Error Handling', () => {
    test('should handle missing Claude result gracefully', () => {
        const claudeResult = null;
        const issueNumber = 42;

        // Test that functions handle null/undefined claudeResult
        const executionTime = Math.round((claudeResult?.executionTime || 0) / 1000);
        const isSuccess = claudeResult?.success || false;
        const sessionId = claudeResult?.sessionId || 'unknown';

        assert.strictEqual(executionTime, 0);
        assert.strictEqual(isSuccess, false);
        assert.strictEqual(sessionId, 'unknown');
    });

    test('should handle empty conversation log', () => {
        const claudeResult = {
            success: true,
            conversationLog: []
        };

        // Test conversation log handling
        const hasConversation = claudeResult?.conversationLog && claudeResult.conversationLog.length > 0;
        assert.strictEqual(hasConversation, false);
    });

    test('should handle malformed conversation messages', () => {
        const claudeResult = {
            conversationLog: [
                { type: 'user', message: null },
                { type: 'assistant', message: { content: null } },
                { type: 'assistant', message: { content: [{ text: 'Valid message' }] } }
            ]
        };

        // Test that we can safely extract content
        claudeResult.conversationLog.forEach(msg => {
            if (msg.type === 'user') {
                const content = msg.message?.content || '[content unavailable]';
                assert(typeof content === 'string');
            } else if (msg.type === 'assistant') {
                const content = msg.message?.content?.[0]?.text || '[content unavailable]';
                assert(typeof content === 'string');
            }
        });
    });
});